{"ast":null,"code":"import Big from \"big.js\";\nimport operate from \"./operate\";\nimport isNumber from \"./isNumber\";\n\n/**\n * Given a button name and a calculator data object, return an updated\n * calculator data object.\n *\n * Calculator data object contains:\n *   previous:String      the running previous\n *   current:String       the current number to be operated on with the previous\n *   operation:String  +, -, etc.\n */\nexport default function calculate(obj, buttonName) {\n  if (buttonName === \"AC\") {\n    return {\n      previous: null,\n      current: null,\n      operation: null\n    };\n  }\n  if (isNumber(buttonName)) {\n    if (buttonName === \"0\" && obj.current === \"0\") {\n      return {};\n    }\n    // If there is an operation, update current\n    if (obj.operation) {\n      if (obj.current) {\n        return {\n          current: obj.current + buttonName\n        };\n      }\n      return {\n        current: buttonName\n      };\n    }\n    // If there is no operation, update current and clear the value\n    if (obj.current) {\n      const current = obj.current === \"0\" ? buttonName : obj.current + buttonName;\n      return {\n        current,\n        previous: null\n      };\n    }\n    return {\n      current: buttonName,\n      previous: null\n    };\n  }\n  if (buttonName === \"%\") {\n    if (obj.operation && obj.current) {\n      const result = operate(obj.previous, obj.current, obj.operation);\n      return {\n        previous: Big(result).div(Big(\"100\")).toString(),\n        current: null,\n        operation: null\n      };\n    }\n    if (obj.current) {\n      return {\n        current: Big(obj.current).div(Big(\"100\")).toString()\n      };\n    }\n    return {};\n  }\n  if (buttonName === \".\") {\n    if (obj.current) {\n      // ignore a . if the current number already has one\n      if (obj.current.includes(\".\")) {\n        return {};\n      }\n      return {\n        current: obj.current + \".\"\n      };\n    }\n    return {\n      current: \"0.\"\n    };\n  }\n  if (buttonName === \"=\") {\n    if (obj.current && obj.operation) {\n      return {\n        previous: operate(obj.previous, obj.current, obj.operation),\n        current: null,\n        operation: null\n      };\n    } else {\n      // '=' with no operation, nothing to do\n      return {};\n    }\n  }\n  if (buttonName === \"+/-\") {\n    if (obj.current) {\n      return {\n        current: (-1 * parseFloat(obj.current)).toString()\n      };\n    }\n    if (obj.previous) {\n      return {\n        previous: (-1 * parseFloat(obj.previous)).toString()\n      };\n    }\n    return {};\n  }\n\n  // Button must be an operation\n\n  // When the user presses an operation button without having entered\n  // a number first, do nothing.\n  // if (!obj.current && !obj.previous) {\n  //   return {};\n  // }\n\n  // User pressed an operation button and there is an existing operation\n  if (obj.operation) {\n    return {\n      previous: operate(obj.previous, obj.current, obj.operation),\n      current: null,\n      operation: buttonName\n    };\n  }\n\n  // no operation yet, but the user typed one\n\n  // The user hasn't typed a number yet, just save the operation\n  if (!obj.current) {\n    return {\n      operation: buttonName\n    };\n  }\n\n  // save the operation and shift 'current' into 'previous'\n  return {\n    previous: obj.current,\n    current: null,\n    operation: buttonName\n  };\n}","map":{"version":3,"names":["Big","operate","isNumber","calculate","obj","buttonName","previous","current","operation","result","div","toString","includes","parseFloat"],"sources":["/Users/nhupham/Desktop/schoolSpr24/cs3398/midterm/reactcalculator_firebase_midterm/src/logic/calculate.js"],"sourcesContent":["import Big from \"big.js\";\n\nimport operate from \"./operate\";\nimport isNumber from \"./isNumber\";\n\n/**\n * Given a button name and a calculator data object, return an updated\n * calculator data object.\n *\n * Calculator data object contains:\n *   previous:String      the running previous\n *   current:String       the current number to be operated on with the previous\n *   operation:String  +, -, etc.\n */\nexport default function calculate(obj, buttonName) {\n  if (buttonName === \"AC\") {\n    return {\n      previous: null,\n      current: null,\n      operation: null,\n    };\n  }\n\n  if (isNumber(buttonName)) {\n    if (buttonName === \"0\" && obj.current === \"0\") {\n      return {};\n    }\n    // If there is an operation, update current\n    if (obj.operation) {\n      if (obj.current) {\n        return { current: obj.current + buttonName };\n      }\n      return { current: buttonName };\n    }\n    // If there is no operation, update current and clear the value\n    if (obj.current) {\n      const current = obj.current === \"0\" ? buttonName : obj.current + buttonName;\n      return {\n        current,\n        previous: null,\n      };\n    }\n    return {\n      current: buttonName,\n      previous: null,\n    };\n  }\n\n  if (buttonName === \"%\") {\n    if (obj.operation && obj.current) {\n      const result = operate(obj.previous, obj.current, obj.operation);\n      return {\n        previous: Big(result)\n          .div(Big(\"100\"))\n          .toString(),\n        current: null,\n        operation: null,\n      };\n    }\n    if (obj.current) {\n      return {\n        current: Big(obj.current)\n          .div(Big(\"100\"))\n          .toString(),\n      };\n    }\n    return {};\n  }\n\n  if (buttonName === \".\") {\n    if (obj.current) {\n      // ignore a . if the current number already has one\n      if (obj.current.includes(\".\")) {\n        return {};\n      }\n      return { current: obj.current + \".\" };\n    }\n    return { current: \"0.\" };\n  }\n\n  if (buttonName === \"=\") {\n    if (obj.current && obj.operation) {\n      return {\n        previous: operate(obj.previous, obj.current, obj.operation),\n        current: null,\n        operation: null,\n      };\n    } else {\n      // '=' with no operation, nothing to do\n      return {};\n    }\n  }\n\n  if (buttonName === \"+/-\") {\n    if (obj.current) {\n      return { current: (-1 * parseFloat(obj.current)).toString() };\n    }\n    if (obj.previous) {\n      return { previous: (-1 * parseFloat(obj.previous)).toString() };\n    }\n    return {};\n  }\n\n  // Button must be an operation\n\n  // When the user presses an operation button without having entered\n  // a number first, do nothing.\n  // if (!obj.current && !obj.previous) {\n  //   return {};\n  // }\n\n  // User pressed an operation button and there is an existing operation\n  if (obj.operation) {\n    return {\n      previous: operate(obj.previous, obj.current, obj.operation),\n      current: null,\n      operation: buttonName,\n    };\n  }\n\n  // no operation yet, but the user typed one\n\n  // The user hasn't typed a number yet, just save the operation\n  if (!obj.current) {\n    return { operation: buttonName };\n  }\n\n  // save the operation and shift 'current' into 'previous'\n  return {\n    previous: obj.current,\n    current: null,\n    operation: buttonName,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}